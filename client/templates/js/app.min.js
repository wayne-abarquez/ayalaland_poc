(function () {
    'use strict';

    angular
        .module('demoApp.home', []);

}());

(function(){
'use strict';

angular.module('demoApp.home')
    .controller('searchLotOfferController', ['$rootScope', '$mdDateRangePicker', 'modalServices', 'boundariesService', 'gmapServices', 'SBU_SELECTION', 'lotService', searchLotOfferController]);

    function searchLotOfferController ($rootScope, $mdDateRangePicker, modalServices, boundariesService, gmapServices, SBU_SELECTION, lotService) {
        var vm = this;

        var bounds;

        vm.sbuList = SBU_SELECTION;

        vm.lotFilterForm = {};

        vm.filter = {};

        vm.selectedRange = {
            selectedTemplate: 'TW',
            selectedTemplateName: 'This Week',
            dateStart: null,
            dateEnd: null,
            showTemplate: false,
            fullscreen: false,
            disableTemplates: "NW",
            maxRange: new Date(),
            onePanel: true
        };

        vm.maxDate = new Date();

        vm.regionChanged = regionChanged;
        vm.provinceChanged = provinceChanged;
        vm.cityChanged = cityChanged;
        vm.close = close;
        vm.pickDateRange = pickDateRange;

        vm.search = search;
        vm.clearFilter = clearFilter;

        initialize();

        function initialize () {
            // load regions typeid = 3
            boundariesService.loadBoundariesByType(3)
                .then(function (regions) {
                    vm.regions = angular.copy(regions);
                });
        }

        function close () {
            modalServices.closeModal();
        }

        function regionChanged(regionId) {
            // fit to bounds
            panToBoundary(regionId);

            // load province
            boundariesService.loadBoundaries(regionId)
                .then(function (provinces) {
                    vm.provinces = angular.copy(provinces);
                });
        }

        function provinceChanged(provinceId) {
            // fit to bounds
            panToBoundary(provinceId);

            // load cities
            boundariesService.loadBoundaries(provinceId)
                .then(function (cities) {
                    vm.cities = angular.copy(cities);
                });
        }

        function cityChanged(cityId) {
            // fit to bounds
            panToBoundary(cityId);
        }

        function panToBoundary(boundaryId) {
            boundariesService.getBoundaryDetails(boundaryId)
                .then(function (details) {
                    bounds = gmapServices.fitToBoundsByLatLngArray(details.geometry);
                });
        }

        function formatDateRangeResult (result) {
            var momentDateStart = moment(result.dateStart);
            vm.filter.date_start = momentDateStart.format('YYYY-MM-DD');
            vm.dateRangeFormatted = momentDateStart.format('MMM D, YYYY');

            var momentDateEnd = moment(result.dateEnd);
            vm.filter.date_end = momentDateEnd.format('YYYY-MM-DD');
            vm.dateRangeFormatted += ' - ' + momentDateEnd.format('MMM D, YYYY');
        }

        function pickDateRange($event, showTemplate) {
            vm.selectedRange.showTemplate = showTemplate;
            $mdDateRangePicker.show({
                targetEvent: $event,
                model: vm.selectedRange
            }).then(function (result) {
                if (result) formatDateRangeResult(result);
            })
        }

        function search (filterData) {
            //console.log('search: ',filterData);
            lotService.filterLot(filterData)
                .then(function(lots){
                    $rootScope.$broadcast('show-lot-filter-result', {result: lots});
                });
        }

        function clearFilter () {
            vm.filter = {};
            vm.lotFilterForm.$setPristine(true);
            vm.provinces = [];
            vm.cities = [];
            vm.dateRangeFormatted = '';

            $rootScope.$broadcast('show-lot-filter-result', {result: []});
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .controller('lotResultTableController', ['$rootScope', lotResultTableController]);

    function lotResultTableController ($rootScope) {
        var vm = this;

        vm.hideLotResultTable = true;

        vm.close = close;

        initialize();

        function initialize () {
            $rootScope.$on('show-lot-filter-result', function (e, params) {
                if (params.result) vm.lots = angular.copy(params.result);
            });
        }

        function close () {
            vm.hideLotResultTable = true;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('lotService', ['Lot', 'gmapServices', '$q', lotService]);

    function lotService (Lot, gmapServices, $q) {
        var service = {};

        var infowindow = gmapServices.createInfoWindow('');

        var lots = [];

        service.loadLots = loadLots;
        service.addLot = addLot;
        service.saveLot = saveLot;
        service.filterLot = filterLot;

        function loadLots () {
            Lot.getList()
                .then(function(response){
                   var resp = response.plain();
                   //console.log('lots: ',resp);
                    resp.forEach(function(item){
                        addLot(item);
                    });
                });
        }

        function addLot (item) {
            //console.log('add lot: ',item);
            var polygon = gmapServices.createPolygon(item.geom, '#2ecc71', true);

            polygon = angular.merge(polygon, item);

            polygon.center = gmapServices.getPolygonCenter(polygon);

            polygon.content = '<div>';
            polygon.content += '<h4 class="no-margin text-muted padding-left-5">Project Name: ' + (item.project_name ? item.project_name : '') + '</h4>';
            polygon.content += '<h4 class="no-margin padding-left-5">Estate Name: <b>' + (item.estate_name ? item.estate_name : '') + '</b></h4>';
            polygon.content += '<h4 class="no-margin text-muted padding-left-5">SBU: ' + (item.sbu ? item.sbu : '') + '</h4>';
            polygon.content += '<h4 class="no-margin text-muted padding-left-5">Lot Status: ' + (item.lot_status ? item.lot_status : '') + '</h4>';
            /* Action Buttons */
            polygon.content += '<button id="show-lot-details-btn" data-lot-id="' + item.id + '" class="md-button md-raised">Show Details</button>';
            polygon.content += '</div>';

            gmapServices.addListener(polygon, 'click', function(e){
                infowindow.open(gmapServices.map);
                //infowindow.setPosition(e.latLng);
                infowindow.setPosition(this.center);
                infowindow.setContent(this.content);
            });

            lots.push(polygon);

            gmapServices.fitToBoundsByPolygon(polygon);
        }

        // if lotId is not null perform update otherwise perform create
        function saveLot (lotData, lotId) {
            var dfd = $q.defer();

            if (lotId) { // update
                Lot.get(lotId)
                    .customPUT(data)
                    .then(function (response) {
                        dfd.resolve(response.plain());
                    }, function (error) {
                        dfd.reject(error);
                    });
            } else { // insert
                Lot.post(lotData)
                    .then(function (response) {
                        var resp = response.plain();
                        console.log('create lot', resp);
                        addLot(resp.lot);
                        dfd.resolve(resp.lot);
                    }, function (error) {
                        dfd.reject(error);
                    });
            }

            return dfd.promise;
        }

        function filterLot (filterData) {
            var dfd = $q.defer();

            Lot.getList(filterData)
                .then(function(response){
                    var resp = response.plain();
                    console.log('filterLot result: ', resp);
                    dfd.resolve(resp);
                }, function (error){
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.home')
        .factory('Lot', ['Restangular', 'Upload', Lot]);

    function Lot(Restangular, Upload) {
        var myModel = Restangular.all('lots');

        var resource = {

            cast: function (myid) {
                return Restangular.restangularizeElement(null, {id: myid}, 'lots');
            },

            uploadShapeFile: function (fileParam) {
                var uploadUrl = myModel.getRestangularUrl() + '/' + 'upload';
                return Upload.upload({
                    url: uploadUrl,
                    method: 'POST',
                    data: {file: fileParam}
                });
            }
        };

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .controller('indexController', ['lotService', 'modalServices', indexController]);

    function indexController (lotService, modalServices) {
        var vm = this;

        vm.createLotOffer = createLotOffer;
        vm.searchLotOffer = searchLotOffer;

        initialize();

        function initialize() {
            lotService.loadLots();
        }

        function createLotOffer (event) {
            modalServices.showCreateLotOfferForm(event);
        }

        function searchLotOffer (event) {
            modalServices.showSearchLotOfferModal(event);
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .controller('gmapController', ['gmapServices', gmapController]);

    function gmapController(gmapServices) {

        var vm = this;

        vm.initialize = initialize;

        vm.initialize();

        function initialize () {
            gmapServices.createMap('map-canvas');
        }
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.home')
        .controller('createLotOfferFormController', ['$rootScope', 'modalServices', 'boundariesService', 'gmapServices', 'lotService', 'alertServices', 'drawingServices', createLotOfferFormController]);

    function createLotOfferFormController($rootScope, modalServices, boundariesService, gmapServices, lotService, alertServices, drawingServices) {
        var vm = this;

        var bounds;
        var drawSiteListener;

        vm.maxDate = new Date();

        vm.form = {};
        vm.newLot = {};

        vm.save = save;
        vm.close = close;

        vm.regionChanged = regionChanged;
        vm.provinceChanged = provinceChanged;
        vm.cityChanged = cityChanged;
        vm.drawBorder = drawBorder;

        initialize();

        function initialize() {
            // load regions typeid = 3
            boundariesService.loadBoundariesByType(3)
                .then(function(regions){
                    vm.regions = angular.copy(regions);
                });
        }

        function save() {
            //console.log('save lot offer', vm.newLot);
            lotService.saveLot(vm.newLot)
                .then(function(newLotData){
                    if (drawingServices.drawPolygon) {
                        drawingServices.drawPolygon.setMap(null);
                        drawingServices.drawPolygon = null;
                    }
                    lotService.addLot(newLotData);
                    alertServices.showSuccess('Offer for lot #'+ newLotData.id+' created successfully!');
                    modalServices.hideResolveModal(newLotData);
                });
        }

        function close() {
            modalServices.closeModal();
        }

        function panToBoundary (boundaryId) {
            boundariesService.getBoundaryDetails(boundaryId)
                .then(function (details) {
                    bounds = gmapServices.fitToBoundsByLatLngArray(details.geometry);

                    gmapServices.reverseGeocode(bounds.getCenter())
                        .then(function(addressList){
                            if (addressList.length) vm.newLot.complete_address = addressList[0].formatted_address;
                        });
                });
        }

        function regionChanged (regionId) {
            // fit to bounds
            panToBoundary(regionId);

            // load province
            boundariesService.loadBoundaries(regionId)
                .then(function (provinces) {
                    vm.provinces = angular.copy(provinces);
                });
        }

        function provinceChanged (provinceId) {
            // fit to bounds
            panToBoundary(provinceId);

            // load cities
            boundariesService.loadBoundaries(provinceId)
                .then(function (cities) {
                    vm.cities = angular.copy(cities);
                });
        }

        function cityChanged (cityId) {
            // fit to bounds
            panToBoundary(cityId);
        }

        function drawBorder () {
            if (drawingServices.drawPolygon && drawingServices.drawPolygon.getMap()) {
                gmapServices.setPolygonEditable(drawingServices.drawPolygon, true);

                $rootScope.$broadcast('edit-drawing-polygon');

                drawSiteListener = $rootScope.$on('save-drawing', function (event, param) {
                    console.log('save-drawing event');
                    gmapServices.setPolygonEditable(drawingServices.drawPolygon, false);
                    vm.newLot.area = gmapServices.getLatLngArrayLiteralPolygon(drawingServices.drawPolygon);
                    console.log('lot area: ', vm.newLot.area);
                });
            } else {
                $rootScope.$broadcast('start-drawing');

                drawSiteListener = $rootScope.$on('save-area', function (event, param) {
                    console.log('save area: ', param);
                    vm.newLot.area = param.area;
                    drawingServices.drawPolygon = gmapServices.createPolygon(param.area, '#2ecc71', true);
                    console.log('lot area: ', vm.newLot.area);
                });
            }

        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('boundariesService', ['Boundaries', '$q', 'Lot', boundariesService]);

    function boundariesService (Boundaries, $q, Lot) {
        var service = {};

        service.boundaries = [];

        service.loadBoundaries = loadBoundaries;
        service.uploadShapeFile = uploadShapeFile;
        service.loadBoundariesByType = loadBoundariesByType;
        service.getBoundaryDetails = getBoundaryDetails;

        function loadBoundaries (parentid) {
            var dfd = $q.defer();

            var pid = parentid || null;

            //Boundaries.getList({parent_id: pid})
            Boundaries.customGET(null, {parent_id: pid})
                .then(function (response) {
                    var list = response.plain();

                    service.boundaries = list.map(function (item) {
                        item['isExpanded'] = false;
                        return item;
                    });

                    dfd.resolve(list);
                }, function (error) {
                    console.log('failed to load: ', error);
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function uploadShapeFile(file) {
            var dfd = $q.defer();

            if (!file) {
                dfd.reject();
            } else {
                file.upload = Lot.uploadShapeFile(file);

                file.upload.then(function (response) {
                    file.result = response.data;
                    dfd.resolve(response.data);
                }, function (error) {
                    dfd.reject(error);
                }, function (evt) {
                    file.progress = Math.min(100, parseInt(100.0 *
                        evt.loaded / evt.total));

                });
            }

            return dfd.promise;
        }

        function loadBoundariesByType (typeid) {
            var dfd = $q.defer();

            Boundaries.customGET(null, {type_id: typeid})
                .then(function (response) {
                    dfd.resolve(response.plain());
                }, function (error) {
                    console.log('failed to load: ', error);
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getBoundaryDetails (boundaryId) {
            var dfd = $q.defer();

             Boundaries.get(boundaryId)
                .then(function (response) {
                    dfd.resolve(response.plain());
                }, function (error) {
                    console.log('failed to load: ', error);
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp.home')
    .factory('Boundaries', ['Restangular', Boundaries]);
    
    function Boundaries (Restangular) {
        var myModel = Restangular.all('boundaries');

        var resource = {
            cast: function (boundaryId) {
                return Restangular.restangularizeElement(null, boundaryId, 'boundaries');
            }
        };

        Restangular.extendModel('boundaries', function (model) {
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.home')
        .controller('boundariesController', ['Boundaries', 'boundariesService', 'gmapServices', '$timeout', boundariesController]);

    function boundariesController(Boundaries, boundariesService, gmapServices, $timeout) {
        var vm = this;

        var polygon,
            circle;

        vm.showBoundary = showBoundary;
        vm.expandCallback = expandCallback;
        vm.uploadShapeFile = uploadShapeFile;

        initialize();

        /* Controller Functions here */

        function initialize() {
            boundariesService.loadBoundaries()
                .then(function (list) {
                    vm.boundaries = angular.copy(list);
                }, function (error) {
                    console.log('failed to load: ', error);
                });

        }

        function showBoundary(brgy) {
            var item = Boundaries.cast(brgy);

            $('md-list-item#' + item.id.toString() + ' md-progress-circular').show();

            item.customGET('circle')
                .then(function(response){
                    console.log('get boundary detail: ', response.plain());

                    showPolygon(response.geometry);

                    gmapServices.fitToBoundsByPolygon(polygon);

                    item.type = response.type;

                    //$mdSidenav('boundariesInfoSidenav').open();
                })
                .finally(function () {
                    $timeout(function () {
                        $('md-list-item#' + item.id.toString() + ' md-progress-circular').hide();
                    }, 1000);
                });
        }

        function showPolygon (latLngArray) {
            if (polygon) {
                polygon.setPath(latLngArray);
                return;
            }

            polygon = gmapServices.createPolygon(latLngArray, '#ff0000');
        }

        function expandCallback (item, event) {
            event.stopPropagation();

            if (item.isExpanded === false) return;

            if (item.typeid < 7) {
                if (item.hasOwnProperty('children') && item.children.length) return;

                $('v-pane#' + item.id.toString() + ' v-pane-header md-progress-circular').show();

                item.children = [];

                $('v-pane#'+item.id.toString()+' v-pane-content v-accordion').children().html('');

                boundariesService.loadBoundaries(item.id)
                    .then(function (list) {
                        if (list.length) item.children = angular.copy(list);
                    }, function (error) {
                        console.log('failed to load: ', error);
                    })
                    .finally(function () {
                        $timeout(function () {
                            $('v-pane#' + item.id.toString() + ' v-pane-header md-progress-circular').hide();
                        }, 1000);
                    });

                return;
            }

            showBoundary(item);

            return;
        }

        function uploadShapeFile (file, errFiles, event) {
            event.stopPropagation();

            if (!file || errFiles.length) {
                alert('File is invalid.');
                return;
            }

            boundariesService.uploadShapeFile(file)
                .then(function (response) {
                    console.log('successfully uploaded shape file: ', response);
                    alert('Data uploaded.');
                }, function (error) {
                    console.log('error on uploading employee data: ', error);
                });
        }

    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp', [
            'restangular',
            'LocalStorageModule',
            'ngMaterial',
            'ngAnimate',
            'oitozero.ngSweetAlert',
            'ngMessages',
            'ngFileUpload',
            'vAccordion',
            'md.data.table',
            'angularMoment',
            'smDateTimeRangePicker',
            'ngMaterialDateRangePicker',
            'demoApp.home'
        ])

        .constant('APP_NAME', 'Ayala Land')
        .constant('BASE_URL', window.location.origin)

        .constant('SBU_SELECTION', [
            'AVIDA',
            'SLMG',
            'ALP'
        ])

        .config(['RestangularProvider', function (RestangularProvider) {
            //set the base url for api calls on our RESTful services
            var baseUrl = window.location.origin + '/api';
            RestangularProvider.setBaseUrl(baseUrl);
        }])

        .config(["localStorageServiceProvider", function (localStorageServiceProvider) {
            localStorageServiceProvider
                .setPrefix('AYALALAND')
                .setStorageType('sessionStorage')
                .setNotify(true, true)
            ;
        }])

        .config(["$mdThemingProvider", function ($mdThemingProvider) {
            //    $mdThemingProvider.theme('default')
            //        .primaryPalette('red')
            //        .accentPalette('pink');
            $mdThemingProvider.theme('docs-dark', 'default')
                .primaryPalette('yellow')
                .dark();
        }])

        .run(["userSessionService", "$rootScope", function (userSessionService, $rootScope) {
            userSessionService.userLogin()
                .then(function (user) {
                    $rootScope.currentUser = angular.copy(user);
                });
        }])

        .filter('underscoreless', function () {
            return function (input) {
                return input.replace(/_/g, ' ');
            };
        })
    ;

}());

String.prototype.capitalize = function () {
    return this.charAt(0).toUpperCase() + this.slice(1);
};

Date.prototype.addDays = function (days) {
    var dat = new Date(this.valueOf())
    dat.setDate(dat.getDate() + days);
    return dat;
};


(function () {
    'use strict';

    angular.module('demoApp')
        .factory('userSessionService', ['User', 'localStorageService', '$q', userSessionService]);

    function userSessionService(User, localStorageService, $q) {
        var service = {};

        // user details
        var USER = 'USER';

        service.userLogin = userLogin;
        service.userLogout = userLogout;
        service.getUserInfo = getUserInfo;

        function userLogin() {
            if (!localStorageService.isSupported) return;

            var dfd = $q.defer();
            var currentUser = getUserInfo();

            if (currentUser) {
                dfd.resolve(currentUser);
            } else {
                User.customGET('current_user')
                    .then(function (response) {
                        localStorageService.set(USER, response.plain());
                        dfd.resolve(response.plain());
                    }, function (error) {
                        dfd.reject(error);
                    });
            }

            return dfd.promise;
        }

        function userLogout() {
            if (!localStorageService.isSupported) return;

            // clear all data on local storage on logout
            localStorageService.clearAll();
        }

        function getUserInfo(isRestangular) {
            if (!localStorageService.isSupported) return;

            var userObj = localStorageService.get(USER);

            return isRestangular && userObj ?
                User.cast(userObj.id)
                : userObj;
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('User', ['Restangular', User]);

    function User(Restangular) {
        var myModel = Restangular.all('users');

        var resource = {
            cast: function (userId) {
                return Restangular.restangularizeElement(null, {id: userId}, 'users');
            }
        };

        Restangular.extendModel('users', function (model) {
            // NOTE: strip restangular removes extra restangular functions on response
            // you can also call plain() function on response if you want want method to be stripped
            //return Restangular.stripRestangular(model);
            return model;
        });

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('modalServices', ['$q', '$mdDialog', '$mdMedia', '$rootScope', modalServices]);

    function modalServices($q, $mdDialog, $mdMedia, $rootScope) {
        var service = {};

        var customFullscreen = $mdMedia('xs') || $mdMedia('sm');

        var createLotOfferModal,
            searchLotOfferModal;

        /* Service Functions */
        service.showCreateLotOfferForm = showCreateLotOfferForm;
        service.showSearchLotOfferModal = showSearchLotOfferModal;
        service.hideResolveModal = hideResolveModal;
        service.closeModal = closeModal;

        function showModal(modalObj, modalParams) {
            var dfd = $q.defer();
            if (modalObj) {
                dfd.reject("Modal already opened");
            } else {
                $rootScope.$broadcast("modal-opened");
                modalObj = $mdDialog.show(modalParams);
                modalObj.then(function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        modalObj = null;
                    });
            }
            return dfd.promise;
        }

        function showCreateLotOfferForm(ev) {
            var opts = {
                controller: 'createLotOfferFormController',
                controllerAs: 'vm',
                templateUrl: '/partials/modals/create_lot_offer_form.html',
                parent: angular.element(document.querySelector('#index-container')),
                targetEvent: ev,
                hasBackdrop: false,
                fullscreen: customFullscreen,
                onComplete: function (scope, element, options) {
                    $('.md-scroll-mask').css('z-index', '-1');
                }
            };

            return showModal(createLotOfferModal, opts);
        }

        function showSearchLotOfferModal(ev) {
            var opts = {
                controller: 'searchLotOfferController',
                controllerAs: 'vm',
                templateUrl: '/partials/modals/search_lot_offer.html',
                parent: angular.element(document.querySelector('#index-container')),
                targetEvent: ev,
                hasBackdrop: false,
                fullscreen: customFullscreen,
                onComplete: function (scope, element, options) {
                    $('.md-scroll-mask').css('z-index', '-1');
                }
            };

            return showModal(searchLotOfferModal, opts);
        }

        function hideResolveModal(response) {
            $rootScope.$broadcast("modal-closed");
            $mdDialog.hide(response);
        }

        // Close Modal
        function closeModal() {
            $rootScope.$broadcast("modal-closed");
            $mdDialog.cancel();
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('mainController', ['$rootScope', '$scope', 'APP_NAME', '$mdSidenav', 'userSessionService', 'drawingServices', 'gmapServices', mainController]);

    function mainController($rootScope, $scope, APP_NAME, $mdSidenav, userSessionService, drawingServices, gmapServices) {
        var vm = this;

        var autocomplete,
            place;

        // drawing tools
        vm.drawBtn = {
            save: false,
            delete: false,
            cancel: false
        };

        $rootScope.appName = APP_NAME;

        /* Side Nav Menus */
        vm.menu = [];

        var MENU_SELECTIONS = [
            //{
            //    link: '/',
            //    title: 'Channel Diversification',
            //    icon: 'track_changes',
            //    can: ['ADMIN', 'SALES']
            //},
            //{
            //    link: '/frauddetect',
            //    title: 'Fraud Detection',
            //    icon: 'fingerprint',
            //    can: ['ADMIN']
            //},
            //{
            //    link: '/productsaturation',
            //    title: 'Product Saturation',
            //    icon: 'assessment',
            //    can: ['ADMIN']
            //},
            {
                link: '/logout',
                title: 'Logout',
                icon: 'exit_to_app',
                can: ['ADMIN', 'SALES']
            }
        ];

        vm.toggleMainMenu = buildToggler('mainMenuSidenav');
        vm.onMenuItemClick = onMenuItemClick;

        vm.stopDrawing = stopDrawing;
        vm.saveArea = saveArea;
        vm.deleteSelected = deleteSelected;

        initialize();

        function initialize() {
            // loads user details
            $rootScope.$watch('currentUser', function (newValue) {
                if (!newValue) return;
                vm.menu = getUserMenu(newValue);
            });

            $rootScope.$on('modal-opened', function () {
                $rootScope.hasOpenedModal = true;
            });

            $rootScope.$on('modal-closed', function () {
                $rootScope.hasOpenedModal = false;
            });

            $rootScope.$on('start-drawing', function (e, params) {
                var strokeColor = params && params.strokeColor ? params.strokeColor : '#1abc9c';
                startDrawing(strokeColor);
            });

            $rootScope.$on('edit-drawing-polygon', function (e, params) {
                // Show Cancel Map button
                vm.drawBtn.cancel = true;
                vm.drawBtn.save = true;
            });

            $rootScope.$on('end-drawing', function () {
                stopDrawing();
            });

            $rootScope.$on('overlay-complete', function () {
                $scope.$apply(function () {
                    vm.drawBtn.save = true;
                    vm.drawBtn.delete = true;
                });
            });

            /* Address Search */
            autocomplete = gmapServices.initializeAutocomplete('address-search-input');

            autocomplete.addListener('place_changed', function(){
                place = autocomplete.getPlace();

                if (!place.geometry) {
                    alert("Autocomplete's returned place contains no geometry");
                    return;
                }

                if (place.geometry.viewport) {
                    gmapServices.map.fitBounds(place.geometry.viewport);
                } else {
                    gmapServices.setZoomIfGreater(17);
                    gmapServices.map.panTo(place.geometry.location);
                }
            });
        }

        function getUserMenu(user) {
            // TODO: this must come from backend
            var result = [];

            MENU_SELECTIONS.forEach(function (item) {
                if (item.can.indexOf(user.role.toUpperCase()) > -1) return result.push(item);
            });

            return result;
        }

        function buildToggler(navID) {
            return function () {
                $mdSidenav(navID)
                    .toggle();
            }
        }

        function onMenuItemClick(item) {
            if (item.title.toLowerCase() == 'logout') {
                // clean local storage
                userSessionService.userLogout();
            }
        }

        /* Drawing Functions */

        function startDrawing(strokeColor) {
            drawingServices.startDrawingMode(strokeColor);
            // Show Cancel Map button
            vm.drawBtn.cancel = true;
        }


        /* Drawing Functions */
        function saveArea() {
            if (drawingServices.drawPolygon) {
                $rootScope.$broadcast('save-drawing');
                for (var key in vm.drawBtn) vm.drawBtn[key] = false;
                return;
            }

            if (!drawingServices.overlay) {
                console.log('Cannot proceed. No Overlay Drawn.')
                return;
            }

            var area = drawingServices.overlayDataArray;
            $rootScope.$broadcast('save-area', {area: area});
            vm.stopDrawing();
        }

        function deleteSelected() {
            if (drawingServices.overlay) {
                drawingServices.clearOverlay();
                vm.drawBtn.save = false;
                vm.drawBtn.delete = false;
            }

            $rootScope.$broadcast('delete-selected');
        }

        function stopDrawing() {
            if (drawingServices.drawPolygon) gmapServices.setPolygonEditable(drawingServices.drawPolygon, false);

            $rootScope.$emit('terminate-drawing');

            drawingServices.stopDrawingMode();

            //projectAreaDrawingServices.stopDrawing();

            // hide draw buttons
            for (var key in vm.drawBtn) vm.drawBtn[key] = false;
        }


    }
}());

(function () {
    'use strict';

    angular.module('demoApp')
        .factory('gmapServices', ['$log', '$q', gmapServices]);

    function gmapServices($log, $q) {
        var service = {};

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 6;
        service.ZOOM_IN_LEVEL = 17;

        service.map = null;
        service.mapProjection = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_OUT_LEVEL;

        service.defaultLatLng = new google.maps.LatLng(10.3194669, 123.9136565);

        // Cluster Objects
        // for Different Layers
        service.markerClusterers = {};

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.destroyPolyline = destroyPolyline;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.panToPolygon = panToPolygon;
        service.fitToBoundsByLatLngArray = fitToBoundsByLatLngArray;
        service.createPolyline = createPolyline;
        service.createDashedPolyline = createDashedPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.loadKMLByURL = loadKMLByURL;
        service.initMapClusterer = initMapClusterer;
        service.destroyMapClusterer = destroyMapClusterer;
        service.createClusterMarker = createClusterMarker;
        service.getClustererInstance = getClustererInstance;
        service.clearClusterMarkers = clearClusterMarkers;
        service.resetClusters = resetClusters;
        service.insertImageMapType = insertImageMapType;
        service.removeOverlayAtIndex = removeOverlayAtIndex;
        service.initializeAutocomplete = initializeAutocomplete;
        service.containsLocation = containsLocation;
        service.triggerEvent = triggerEvent;
        service.createMapIconLabel = createMapIconLabel;
        service.setlatLngArrayToLatLngObjects = setlatLngArrayToLatLngObjects;
        service.fitToBoundsByPolygon = fitToBoundsByPolygon;
        service.setPolygonEditable = setPolygonEditable;
        service.getLatLngArrayLiteralPolygon = getLatLngArrayLiteralPolygon;
        service.getPolygonCenter = getPolygonCenter

        service.createDrawingManager = createDrawingManager;
        service.changeDrawingManagerStrokeColor = changeDrawingManagerStrokeColor;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;

        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId) {
            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            if (service.map) return service.map;
            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.defaultLatLng,
                mapTypeId: google.maps.MapTypeId.MAP,
                mapTypeControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_TOP
                },
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                panControl: false
            };

            //$(myMapId).height($(window).height() - (42));
            $(myMapId).height($(window).height());

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // initialize geocoder
            //service.geocoder = new google.maps.Geocoder();

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height());
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            return service.map;
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if (!(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function (infobox, index) {
                if (infobox) {
                    infobox.close();
                }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            var marker = service.initMarker(_position, _color);

            //service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            return service.initMarker(_position, icon);
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if (_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else {
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.hideMarker(marker);
            });
        }

        function destroyPolyline(polyline) {
            if (polyline && polyline instanceof google.maps.Polyline) polyline.setMap(null);
            service.clearInstanceListeners(polyline);
            polyline = null;
        }

        function destroyMarker(marker) {
            if (marker instanceof Cluster) {
                marker.remove();
            }
            else if (marker instanceof google.maps.Marker) {
                service.hideMarker(marker);
                service.clearInstanceListeners(marker);
            }
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
            }
        }

        function getPolygonCenter (polygon) {
            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach(function(latlng){
                bounds.extend(latlng);
            });

            return bounds.getCenter().toJSON();
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.defaultLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if (!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function createCircle (centerLatLng, radiusParam, color) {
            return new google.maps.Circle({
                strokeColor: color || '#FF0000',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: color || '#FF0000',
                fillOpacity: 0.35,
                map: service.map,
                center: centerLatLng,
                radius: radiusParam
            });
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, _color, isFilled) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var polygonOptions = {
                path: path,
                //clickable: false,
                draggable: false,
                editable: false,
                fillColor: strokeColor,
                fillOpacity: isFilled ? 0.5 : 0,
                strokeColor: strokeColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polygon(polygonOptions);
        }

        function createPolygon(path, _color, isFilled) {
            var polygon = service.initPolygon(path, _color, isFilled);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function panToPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach(function (path) {
                bounds.extend(path);
            });

            service.map.panToBounds(bounds);
            console.log('panToPolygon: ', polygon);
        }

        function fitToBoundsByLatLngArray (arrayLatLng) {
            var bounds = new google.maps.LatLngBounds();

            arrayLatLng.forEach(function (latlng) {
                bounds.extend(latlng);
            });

            service.map.fitBounds(bounds);

            return bounds;
        }

        function createPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function createDashedPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;

            var lineSymbol = {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 1
            };

            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '3px'
                }],
                strokeOpacity: 0,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable())
                google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable())
                google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable())
                google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) {
                service.geocoder = new google.maps.Geocoder();
            }

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function loadKMLByURL(srcUrl, kmlOptions) {
            if (service.map) {
                var opt = {
                    url: srcUrl,
                    map: service.map,
                    preserveViewport: true
                };

                if (kmlOptions) {
                    opt = angular.extend({}, opt, kmlOptions);
                }

                return new google.maps.KmlLayer(opt);
            }
            return null;
        }

        function loadClusterStyles(layerName) {
            var defaultStyle = 'resources/images/cluster_icons/m';

            if (layerName == 'meters') {
                return defaultStyle;
            } else if (layerName == 'transformers') {
                return 'resources/images/cluster_icons/transformers/m';
            } else if (layerName == 'poles') {
                return 'resources/images/cluster_icons/poles/m';
            }
            return defaultStyle;
        }

        function initMapClusterer(layerName) {
            if (!service.markerClusterers[layerName]) {
                var clusterStyle = loadClusterStyles(layerName);

                service.markerClusterers[layerName] = new MarkerClusterer(service.map, [],
                    {imagePath: clusterStyle});

                return service.markerClusterers[layerName];
            }
            return null;
        }

        function destroyMapClusterer(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName] = null;
            }
        }

        function createClusterMarker(_position, clusterCount, layerName) {
            if (!service.apiAvailable() || !service.markerClusterers[layerName]) return null;

            var latLngObj = new google.maps.LatLng(_position.lat, _position.lng)
            var cluster = new Cluster(service.markerClusterers[layerName]);

            cluster.center_ = latLngObj;

            cluster.clusterIcon_.setCenter(latLngObj);
            cluster.clusterIcon_.setSums({text: clusterCount, index: Math.round(Math.log(clusterCount) / Math.LN10)});
            cluster.clusterIcon_.textColor_ = 'white';
            cluster.clusterIcon_.show();
            cluster.clusterIcon_.triggerClusterClick = function () {
                var currentZoom = service.map.getZoom();
                service.map.setZoom(++currentZoom);
                service.map.setCenter(cluster.center_);
            };

            return cluster;
        }

        function getClustererInstance(layerName) {
            return service.markerClusterers[layerName];
        }

        function clearClusterMarkers(clusterArray) {
            clusterArray.forEach(function (item, index) {
                if (item instanceof Cluster) {
                    item.remove();
                }
                clusterArray[index] = null;
            });
        }

        function resetClusters(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName].clusters_ = [];
            }
        }

        function insertImageMapType(srcUrl, insertIndex) {
            if (!service.apiAvailable()) return;

            var _insertIndex = insertIndex || 0;

            var imageTile = new google.maps.ImageMapType({
                getTileUrl: function (coord, zoom) {
                    var z2 = Math.pow(2, zoom);
                    var y = coord.y,
                        x = coord.x >= 0 ? coord.x : z2 + coord.x

                    return srcUrl + '/' + zoom + "/" + x + "/" + y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                isPng: true,
                opacity: 1.0
            });

            service.map.overlayMapTypes.insertAt(_insertIndex, imageTile);

            return _insertIndex;
        }

        function removeOverlayAtIndex(index) {
            service.map.overlayMapTypes.setAt(index, null);
        }

        function initializeAutocomplete(elementId) {
            var input = document.getElementById(elementId);
            var autocomplete = new google.maps.places.Autocomplete(input, {
                types: ["geocode"],
                componentRestrictions: {
                    country: 'PH'
                }
            });

            //autocomplete.bindTo('bounds', service.map);

            return autocomplete;
        }

        function containsLocation(latLng, polygon) {
            if (!polygon) return;

            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        }

        function triggerEvent(obj, event) {
            google.maps.event.trigger(obj, 'click');
        }

        function createMapIconLabel(latLng, type, color) {
            return new Marker({
                map: service.map,
                position: latLng,
                icon: {
                    anchor: new google.maps.Point(-6, -10),
                    path: MAP_PIN,
                    fillColor: color || '#2ecc71',
                    fillOpacity: 1,
                    strokeColor: color ? '' : '#27ae60',
                    strokeWeight: color ? 0 : 1
                },
                map_icon_label: '<span class="map-icon map-icon-' + type + '"></span>'
            });
        }

        service.createFacilityMarker = createFacilityMarker;

        function createFacilityMarker (latLng) {
            return service.initMarker(latLng, 'resources/images/markers/wifi.png');
        }

        function fitToBoundsByPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach(function (path) {
                bounds.extend(path);
            });

            service.map.fitBounds(bounds);
        }

        function setlatLngArrayToLatLngObjects (latLngArray) {
            return latLngArray.map(function(latlng){
               return new google.maps.LatLng(latlng);
            });
        }

        function setPolygonEditable(polygon, bool) {
            if (!service.map || !polygon) return;

            polygon.setOptions({draggable: bool, editable: bool});
        }

        function getLatLngArrayLiteralPolygon (polygon) {
            var result = [];

            polygon.getPath().forEach(function(latlng){
                result.push(latlng.toJSON());
            });

            console.log('getLatLngArrayLiteralPolygon result: ',result);

            return result;
        }

        /* Drawing functions */

        function createDrawingManager(_color, fillOpac) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    //fillColor: '#ffffff',
                    fillColor: strokeColor,
                    fillOpacity: fillOpac || 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    //fillColor: '#ffffff',
                    fillColor: strokeColor,
                    fillOpacity: fillOpac || 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function changeDrawingManagerStrokeColor(color, fillOpac) {
            if (!service.apiAvailable() && !service.drawingManager) return null;

            var strokeColor = color || '#0000ff';

            service.drawingManager.setOptions({
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: strokeColor,
                    fillOpacity: fillOpac || 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: strokeColor,
                    fillOpacity: fillOpac || 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });

        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if (!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }
        return service;
    }
}());


(function () {
    'use strict';

    angular.module('demoApp')
        .factory('drawingServices', ['gmapServices', '$rootScope', drawingServices]);

    function drawingServices(gmapServices, $rootScope) {

        var service = {};
        service.drawingManager = null;
        service.drawingCompleteListener = null;

        service.drawPolygon = null;

        service.overlay = null;
        service.overlayType = '';
        service.overlayDataArray = [];

        service.strokeColor = '';

        /**
         * Functions
         */
        service.initDrawingManager = initDrawingManager;
        service.initDrawingListener = initDrawingListener;
        service.setPanControl = setPanControl;
        service.hideDrawingManager = hideDrawingManager;
        service.startDrawingMode = startDrawingMode;
        service.setListenerOfType = setListenerOfType;
        service.stopDrawingMode = stopDrawingMode;
        service.hideOverlay = hideOverlay;
        service.clearOverlay = clearOverlay;
        service.getAreaCoords = getAreaCoords;
        service.getAreaFormData = getAreaFormData;
        service.getPolygonCoords = getPolygonCoords;
        service.getRectangleCorners = getRectangleCorners;
        service.getRectangleCoords = getRectangleCoords;


        function initDrawingManager() {
            if (service.drawingManager) {
                if (service.overlayStrokeColor) gmapServices.changeDrawingManagerStrokeColor(service.overlayStrokeColor);

                // Reinitialize Drawing Listener
                service.initDrawingListener();
                return;
            }

            service.drawingManager = gmapServices.createDrawingManager(service.overlayStrokeColor);
            service.initDrawingListener();
        }


        function initDrawingListener() {
            if (!service.drawingManager) return;

            if (service.drawingCompleteListener) return;

            service.drawingCompleteListener = gmapServices.addListener(
                service.drawingManager, 'overlaycomplete', overlayCompleteListener);
        }


        function overlayCompleteListener(eventArgs) {
            // Set only one overlay
            if (service.overlay) {
                service.overlay.setMap(null);
                service.overlay = null;
                service.overlayDataArray = [];
            }

            service.overlay = eventArgs.overlay;
            service.overlay.setMap(gmapServices.map);

            service.overlayType = eventArgs.type;
            service.overlayDataArray = service.getAreaCoords();

            // Add Listener when overlay is resized
            service.setListenerOfType(eventArgs, function (args) {
                service.overlay = args.overlay;
                service.overlayType = args.type;
                service.overlayDataArray = service.getAreaCoords();
            });

            // Set control to pan every after drawing
            service.setPanControl();

            $rootScope.$broadcast('overlay-complete');
        }


        function setPanControl() {
            service.drawingManager.setDrawingMode(null);
        }


        function hideDrawingManager() {
            if (service.drawingManager) {
                gmapServices.hideDrawingManager(service.drawingManager);
            }
        }

        function startDrawingMode(strokeColor) {
            if (strokeColor) service.overlayStrokeColor = strokeColor;

            service.initDrawingManager();

            gmapServices.showDrawingManager(service.drawingManager);
        }

        function setListenerOfType(eArgs, callbackFn) {
            switch (eArgs.type) {
                // Add Listener Events For Rectangle Changed
                case google.maps.drawing.OverlayType.RECTANGLE:
                    google.maps.event.addListener(eArgs.overlay, 'bounds_changed', function () {
                        callbackFn(eArgs);
                    });
                    break;
                // Add Listener Events For Polygon Changed
                case google.maps.drawing.OverlayType.POLYGON:
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'set_at', function () {
                        callbackFn(eArgs);
                    });
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'insert_at', function (e) {
                        callbackFn(eArgs);
                    });
            }
        }

        function stopDrawingMode() {
            if (service.drawingCompleteListener) {
                gmapServices.removeListener(service.drawingCompleteListener);
                service.drawingCompleteListener = null;
            }

            service.hideDrawingManager();

            service.hideOverlay();
        }

        function cancelDrawingMode() {
            service.stopDrawingMode();
        }

        function hideOverlay() {
            if (!service.overlay) return;

            service.overlay.setMap(null);
            service.overlay = null;
        }

        function clearOverlay() {
            hideOverlay();

            service.overlayDataArray = [];
            service.overlayType = '';
        }

        function getAreaCoords() {
            if (service.overlayType == google.maps.drawing.OverlayType.POLYGON) {
                return service.getPolygonCoords();
            }
            else if (service.overlayType == google.maps.drawing.OverlayType.RECTANGLE) {
                return service.getRectangleCorners();
            }

            return [];
        }

        function getPolygonCoords(_polygon) {
            var polygon = _polygon || service.overlay;

            if (!polygon) return;

            var path = polygon.getPath().getArray();
            var data = [];

            for (var index in path) {
                data.push({
                    lat: path[index].lat(),
                    lng: path[index].lng()
                });
            }

            return data;
        }

        function getAreaFormData(_area) {
            return getPolygonCoords(_area);
        }

        function getRectangleCorners(_rect) {
            var rect = _rect || service.overlay;

            if (!rect) return;

            var bounds = rect.getBounds();
            var min = bounds.getNorthEast();
            var max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});
            data.push({lat: min.lat(), lng: max.lng()});

            return data;
        }

        function getRectangleCoords() {
            if (!service.overlay) return;

            var bounds = service.overlay.getBounds();
            var min = bounds.getNorthEast(),
                max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});

            return data;
        }

        return service;
    }

}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('alertServices', ['$mdToast', 'SweetAlert', alertServices]);

    function alertServices($mdToast, SweetAlert) {
        var service = {};

        service.showBottomLeftToast = showBottomLeftToast;
        service.showTopRightToast = showTopRightToast;
        service.showNoDataAvailablePrompt = showNoDataAvailablePrompt;
        service.showDismissableToast = showDismissableToast;

        service.showConfirm = showConfirm;
        service.showSuccess = showSuccess;
        service.showInfo = showInfo;
        service.showError = showError;


        function showToast(message, position, delay) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position(position)
                    .hideDelay(delay || 2000)
            );
        }

        function showBottomLeftToast(message, delay) {
            showToast(message, 'bottom left', delay);
        }

        function showTopRightToast(message, delay) {
            showToast(message, 'top right', delay);
        }

        function showDismissableToast(message, delay) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position('bottom left')
                    .hideDelay(delay)
            );
        }

        function showNoDataAvailablePrompt(entityName) {
            service.showBottomLeftToast('No ' + entityName + ' data available for this area.');
        }

        function showMessage(message, type, isAutoClose) {
            var opts = {
                title: message,
                type: type
            };

            if (isAutoClose) {
                angular.merge(opts, {timer: 1500, showConfirmButton: false});
            }

            return SweetAlert.swal(opts);
        }

        function showSuccess(message) {
            return showMessage(message, 'success');
        }

        function showError(message) {
            return showMessage(message, 'error');
        }

        function showInfo(message, isAutoClose) {
            return showMessage(message, 'info', isAutoClose);
        }

        function showConfirm(title, message, callbackOnConfirm) {
            return SweetAlert.swal({
                    title: title,
                    text: message,
                    type: "warning",
                    showCancelButton: true,
                    confirmButtonColor: "#DD6B55",
                    confirmButtonText: "Yes",
                    closeOnConfirm: true
                },
                callbackOnConfirm);
        }

        return service;
    }
}());